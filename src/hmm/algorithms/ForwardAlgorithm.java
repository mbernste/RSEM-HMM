package hmm.algorithms;

import hmm.HMM;
import hmm.State;

import java.util.ArrayList;
import java.util.Collection;

import pair.Pair;

/**
 * Implementation of the Forward algorithm for calculating the full probability
 * of a sequence generated by a hidden Markov model.
 * 
 * @author matthewbernstein
 *
 */
public class ForwardAlgorithm 
{	
	/**
	 * Given a HMM model and sequence generated from the HMM, the forward 
	 * algorithm computes the full probability of the sequence under the 
	 * model.  The algorithm also returns the full dynamic programming matrix.
	 * The (i,j) entry in the matrix is the joint probability of generating
	 * j characters in the sequence and being in state i.
	 * 
	 * @param model the hidden Markov model object
	 * @param sequence the sequence produced by the HMM
	 * @return the full probability of the sequence as well as the dynamic
	 * programming matrix
	 */
	public static Pair<Double, DpMatrix> run(HMM model, String sequence)
	{
		DpMatrix dpMatrix = new DpMatrix(model, sequence);
	
		/*
		 *  Initialize the matrix
		 */
		intitialize(dpMatrix, model);
		
		/*
		 *  Run the algorithm
		 */
		Double finalProb = runIteration(dpMatrix, model, sequence);

		printResults(dpMatrix, model, sequence, finalProb);
		
		return new Pair<Double, DpMatrix>(finalProb, dpMatrix);
	}

	private static Double runIteration(DpMatrix dpMatrix, 
									  HMM model, 
									  String sequence)
	{	
		
		/*
		 * Get the states
		 */
		Collection<State> states = model.getStateContainer().getStates();
		
		//********************************************************************
		// Fill in the Dynamic Programming matrix
		//********************************************************************
		
		for (int t = 1; t < dpMatrix.getNumColumns(); t++)
		{	
			System.out.println("I " + t);
			
			/*
			 * Iterate through all non-silent states
			 */
			for (State currState : states)
			{
				if (!currState.isSilent())
				{
					/*
					 *  The emission probability of the current symbol at the 
					 *  ith time step.
					 */
					double eProb = model.getEmissionProb(currState.getId(), 
							  			Character.toString(sequence.charAt(t-1)));
					
					/*
					 * Sum over previous time-step
					 */
					double sum = 0;
					for (State lastState : states)
					{
						double fValue = dpMatrix.getValue(lastState, t-1);
						
						double tProb  = model.getTransitionProb(lastState.getId(), 
															    currState.getId());						
						sum += (fValue * tProb);
					}	
					double newFValue = sum * eProb;
											
					/*
					 *  Set the new value in the DP matrix
					 */
					dpMatrix.setValue(currState, t, newFValue);
				}
			}
			
			/*
			 * Iterate through all silent states
			 */
			for (State currState : states)
			{
				if  (currState.isSilent())
				{
					/*
					 * Sum over previous time-step
					 */
					double sum = 0;
					for (State lastState : states)
					{
						double fValue = dpMatrix.getValue(lastState, t);
						
						double tProb  = model.getTransitionProb(lastState.getId(), 
															    currState.getId());
						sum += (fValue * tProb);
					}	
					double newFValue = sum;
						
					/*
					 *  Set the new value in the DP matrix
					 */
					dpMatrix.setValue(currState, t, newFValue);
				}
			}
			
			System.out.println(dpMatrix);
		}
		
		/*
		 * Compute the final probability of the sequence by summing over the
		 * joint probability of observing the sequence (i.e. of being in the 
		 * last time step) in each state.
		 */
		double sum = 0;
		for (State state : states)
		{	
			double fValue = dpMatrix.getValue(state, dpMatrix.getNumColumns() - 1);
			sum += fValue;
		}
		
		return sum;
	}
	
	/**
	 * Initialize the dynamic programming matrix
	 * 
	 * @param dpMatrix the dynamic programming matrix object
	 * @param model the HMM object
	 */
	private static void intitialize(DpMatrix dpMatrix, HMM model)
	{
		
		/*
		 *  Set all elements to 0.0
		 */
		for (State state : model.getStateContainer().getStates())
		{
			dpMatrix.setValue(state, 0, 0.0);
		}
		
		/*
		 *  Set coordnate (0,0) to 1.0 corresponding to 100% probability
		 *  that we are in the begin state at time step 0
		 */
 		State beginState = model.getBeginState();
		dpMatrix.setValue(beginState, 0, 1.0);
		
		Collection<State> states = model.getStateContainer().getStates();
		for (State currState : states)
		{
			if  (currState.isSilent() && currState != beginState)
			{
				/*
				 * Sum over previous time-step
				 */
				double sum = 0;
				for (State lastState : states)
				{
					double fValue = dpMatrix.getValue(lastState, 0);
					
					double tProb  = model.getTransitionProb(lastState.getId(), 
														    currState.getId());
					sum += (fValue * tProb);
				}	
				double newFValue = sum;
					
				/*
				 *  Set the new value in the DP matrix
				 */
				dpMatrix.setValue(currState, 0, newFValue);
			}
		}
		
		System.out.println(dpMatrix);
	}
	
	private static void printResults(DpMatrix dpMatrix,
									HMM model,
									String sequence,
									Double finalProb)
	{
		for (int t = 0; t < sequence.length(); t++)
		{
			for (State state : model.getStateContainer().getStates())
			{
				if (!state.equals(model.getBeginState()) &&
					!state.equals(model.getEndState()))
				{
					System.out.println("alpha for state " + state.getId() + 
						" time " + (t) + ": " + 
						dpMatrix.getValue(state, t));
				}
			}
			System.out.println("\n-------------------");
		}
		
		System.out.println("Forward probability: " + finalProb);
	}
}
